{"meta":{"title":"forest-sweet hexo blog","subtitle":"","description":"","author":"forest-sweet","url":"https://forest-sweet.github.io","root":"/"},"pages":[{"title":"关于","date":"2025-08-03T03:41:48.000Z","updated":"2025-08-03T03:45:07.331Z","comments":false,"path":"about/index.html","permalink":"https://forest-sweet.github.io/about/","excerpt":"","text":"这是我的博客"},{"title":"归档","date":"2025-08-03T03:41:48.000Z","updated":"2025-08-03T13:47:47.385Z","comments":false,"path":"archives/index.html","permalink":"https://forest-sweet.github.io/archives/","excerpt":"","text":""},{"title":"标签","date":"2025-08-03T03:42:48.000Z","updated":"2025-08-03T03:46:02.859Z","comments":false,"path":"tags/index.html","permalink":"https://forest-sweet.github.io/tags/","excerpt":"","text":""},{"title":"分类","date":"2025-08-03T03:42:18.000Z","updated":"2025-08-03T03:45:41.707Z","comments":false,"path":"categories/index.html","permalink":"https://forest-sweet.github.io/categories/","excerpt":"","text":""}],"posts":[{"title":"KMP算法","slug":"KMP算法","date":"2025-10-02T04:26:21.000Z","updated":"2025-10-10T13:35:51.469Z","comments":true,"path":"2025/10/02/KMP算法/","permalink":"https://forest-sweet.github.io/2025/10/02/KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"KMP算法我是在完成力扣28题时，才知道KMP算法的。此算法可以在O(n+m)的时间复杂度内，完成字符串匹配，相较于暴力匹配的O(nm)时间复杂度，KMP算法的效率要高很多。因此在这学习并记录一下KMP算法的实现。 KMP算法原理KMP算法的核心思想是利用已经匹配过的信息，避免重复匹配。当在主字符串中遇到不匹配的字符时，KMP算法不会回溯主字符串，而是利用模式字符串中的部分匹配信息，直接跳过一些字符，从而提高匹配效率。与暴力匹配不同，KMP算法在匹配过程中，不会重复匹配已经匹配过的字符。 1. 暴力匹配暴力匹配是一种简单的字符串匹配算法，其基本思想是从主字符串的第一个字符开始，与模式字符串的第一个字符进行比较。如果匹配成功，继续比较下一个字符；如果匹配失败，将主字符串的下一个字符作为新的起始位置，重新与模式字符串的第一个字符进行比较。重复这个过程，直到找到匹配的子字符串或主字符串遍历完毕。 下面通过图示来说明暴力匹配的过程： 这个算法的原理很简单，实现起来也十分容易，但最大的问题在于它的时间复杂度，假如你运气不好，恰好碰到主串和子串都是若干个 A，最后仅跟一个 B 的情况。这个时候算法会很傻地把前面的 A 都比对完，然后发现最后一个字符不匹配，于是跳回下一个字符重新比对，做了不少的无用功。 2. KMP算法KMP算法通过预处理模式字符串，构建前缀表（也称为next数组），来记录模式字符串中每个位置的最长相同前后缀的长度。当在主字符串中遇到不匹配的字符时，KMP算法利用前缀表，直接跳过一些字符，不像是暴力匹配那样，重新从主串下一个字符开始。换句话说，我们不希望递减主串的这个指针，而让它永远向前方移动，从而避免重复匹配，提高匹配效率。 KMP算法步骤1.构建部分匹配表（next数组）：前缀： 模式字符串的前缀是指从字符串的开头开始的连续子串，但不包括最后一个字符。后缀： 模式字符串的后缀是指从字符串的结尾开始的连续子串，但不包括第一个字符。部分匹配值： 前缀和后缀的最长公共元素的长度。例如，模式字符串”ABABC”的前缀有”A”, “AB”, “ABA”, “ABAB”，后缀有”C”, “BC”, “ABC”, “BABC”，最长公共元素的长度为2，因此”ABABC”的部分匹配值为2。 next 数组的本质，其实就是寻找子串中相同前后缀的长度，并且一定是最长的前后缀。例如，模式字符串”ABABC”的next数组为[-1, 0, 0, 1, 2]，其中next[i]表示模式字符串的前i个字符中，最长的相同前后缀的长度。 next 数组的构建过程：定义两个指针i和j，j代表前缀的结束位置和子串的最长相等前后缀的长度，i代表后缀的结束位置。 j初始值为0，i初始值为1,next[0]初始值为0。 当模式字符串的第i个字符和第j个字符相等时，说明找到了一个更长的相同前后缀，j++;next[i] &#x3D; j;i++; 当模式字符串的第i个字符和第j个字符不相等时，说明当前的相同前后缀长度不能扩展，需要回退到前一个位置的相同前后缀长度。这可以通过将j回退到next[j-1]的位置来实现。(可能需要回退多次，直到j为0或当前字符匹配)，若j回退到0仍不匹配，说明当前字符与前缀的第一个字符也不匹配，next[i] &#x3D; 0;i++; 初始时 j为0且当前字符不匹配时，next[i] &#x3D; 0;i++; 当前字符匹配时，j++;next[i] &#x3D; j;i++; 字符不匹配时，j回退到next[j-1]的位置，直到j为0或当前字符匹配。 构建next数组的伪代码：j,i,next[0]有两种初始化情况: j&#x3D;0,i&#x3D;1,next[0]&#x3D;0,更易理解； j&#x3D;-1,i&#x3D;0,next[0]&#x3D;-1,更方便计算next数组； 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;// 构建next数组 (next[0] = 0)vector&lt;int&gt; buildNext(const string&amp; pattern) &#123; int n = pattern.length(); vector&lt;int&gt; next(n, 0); // 初始化为0 int j = 0, i = 1; // j初始化为0，i初始化为1 while (i &lt; n) &#123; if (pattern[i] == pattern[j]) &#123; j++; // 找到匹配，j增加 next[i] = j; // 设置next值 i++; // i向后移动 &#125; else &#123; if (j &gt; 0) &#123; j = next[j - 1]; // 回退j到前一个位置的next值 &#125; else &#123; next[i] = 0; // j为0时，无法回退，设置next为0 i++; // i向后移动 &#125; &#125; &#125; return next;&#125; 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;// 构建next数组 (next[0] = -1)vector&lt;int&gt; buildNext(const string&amp; pattern) &#123; int n = pattern.length(); vector&lt;int&gt; next(n, -1); int i = 0, j = -1; while (i &lt; n - 1) &#123; if (j == -1 || pattern[i] == pattern[j]) &#123; i++; j++; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125; return next;&#125; 2. 进行字符串匹配： - 初始化两个指针i和j，分别指向主字符串和模式字符串的第一个字符。 - 当j为-1时，或者当前字符匹配时，i和j都向右移动一位。 - 当当前字符不匹配时，j回退到next[j]的位置，直到j为-1或当前字符匹配。 - 如果j移动到了模式字符串的末尾，说明匹配成功，返回匹配的起始位置。 - 否则，继续匹配。 12345678910111213141516171819202122232425//KMP搜索算法vector&lt;int&gt; kmpSearch(const string&amp; text, const string&amp; pattern, const vector&lt;int&gt;&amp; next) &#123; vector&lt;int&gt; matches; int n = text.length(); int m = pattern.length(); int i = 0, j = 0; while (i &lt; n) &#123; if (j == -1 || text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; // 找到完整匹配 if (j == m) &#123; matches.push_back(i - j); // 找到匹配后，模式串可能还有重叠部分可以继续匹配,继续寻找下一个匹配 //因为当前匹配的末尾部分可能包含下一个匹配的开头部分，所以需要回退到前一个位置的next值 j = next[j - 1]; // 回退到前一个位置 &#125; &#125; return matches;&#125; KMP算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int strStr(string haystack, string needle) &#123; //边界情况处理：如果needle为空字符串，返回0 int n = haystack.size(), m = needle.size(); if (m == 0) &#123; return 0; &#125; //构建部分匹配表（next数组） vector&lt;int&gt; pi(m); for (int i = 1, j = 0; i &lt; m; i++) &#123; while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (needle[i] == needle[j]) &#123; j++; &#125; pi[i] = j; &#125; //进行字符串匹配(只返回第一个匹配位置) for (int i = 0, j = 0; i &lt; n; i++) &#123; while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (haystack[i] == needle[j]) &#123; j++; &#125; if (j == m) &#123; return i - m + 1; &#125; &#125; //进行字符串匹配(返回所有匹配位置) vector&lt;int&gt; result; for (int i = 0, j = 0; i &lt; n; i++) &#123; while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (haystack[i] == needle[j]) &#123; j++; &#125; if (j == m) &#123; result.push_back(i - m + 1); // 记录位置 // 关键：继续匹配，回退j以便找到重叠的匹配 j = pi[j - 1]; &#125; &#125; return -1;//或return result; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class KMP &#123;private: string pattern; vector&lt;int&gt; next; public: // 构造函数，预计算next数组 KMP(const string&amp; pat) : pattern(pat) &#123; buildNext(); &#125; // 构建next数组 void buildNext() &#123; int n = pattern.length(); next.resize(n, -1); int i = 0, j = -1; while (i &lt; n - 1) &#123; if (j == -1 || pattern[i] == pattern[j]) &#123; i++; j++; // 优化：如果回退后字符相同，则继续回退 //核心思想：避免已知必然失败的比较，直接跳转到更有可能成功的位置,这种优化在处理包含大量重复字符的模式串时效果尤其明显！ if (pattern[i] != pattern[j]) &#123; next[i] = j; &#125; else &#123; next[i] = next[j]; &#125; &#125; else &#123; j = next[j]; &#125; &#125; &#125; // 搜索所有匹配位置 vector&lt;int&gt; search(const string&amp; text) &#123; vector&lt;int&gt; matches; int n = text.length(); int m = pattern.length(); int i = 0, j = 0; while (i &lt; n) &#123; if (j == -1 || text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; if (j == m) &#123; matches.push_back(i - j); j = next[j - 1]; &#125; &#125; return matches; &#125; // 搜索第一个匹配位置 int searchFirst(const string&amp; text) &#123; int n = text.length(); int m = pattern.length(); int i = 0, j = 0; while (i &lt; n) &#123; if (j == -1 || text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; if (j == m) &#123; return i - j; &#125; &#125; return -1; // 未找到 &#125; // 打印next数组 void printNext() const &#123; cout &lt;&lt; &quot;Pattern: &quot; &lt;&lt; pattern &lt;&lt; endl; cout &lt;&lt; &quot;Next array: [&quot;; for (int i = 0; i &lt; next.size(); i++) &#123; cout &lt;&lt; next[i]; if (i &lt; next.size() - 1) cout &lt;&lt; &quot;, &quot;; &#125; cout &lt;&lt; &quot;]&quot; &lt;&lt; endl; &#125;&#125;;// 测试函数void testKMP() &#123; string text = &quot;ABABDABACDABABCABAB&quot;; string pattern = &quot;ABABC&quot;; // 创建KMP对象 KMP kmp(pattern); // 打印信息 cout &lt;&lt; &quot;Text: &quot; &lt;&lt; text &lt;&lt; endl; kmp.printNext(); // 搜索所有匹配 vector&lt;int&gt; matches = kmp.search(text); cout &lt;&lt; &quot;所有匹配位置: &quot;; for (int pos : matches) &#123; cout &lt;&lt; pos &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; // 搜索第一个匹配 int firstMatch = kmp.searchFirst(text); cout &lt;&lt; &quot;第一个匹配位置: &quot; &lt;&lt; firstMatch &lt;&lt; endl;&#125;int main() &#123; testKMP(); return 0;&#125; 总结KMP算法是一种高效的字符串匹配算法，通过利用已经匹配过的信息，避免重复匹配，从而提高匹配效率。在实际应用中，KMP算法被广泛用于字符串匹配、文本编辑器、编译器等领域。","categories":[{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://forest-sweet.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2025-08-01T02:07:13.000Z","updated":"2025-10-02T14:08:32.223Z","comments":true,"path":"2025/08/01/我的第一篇博客/","permalink":"https://forest-sweet.github.io/2025/08/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"我的第一篇博客欢迎来到我的博客！这是我发布的第一篇文章。在这里，我将分享我的学习经历、技术见解以及生活点滴。希望你能在这里找到有价值的内容，也欢迎你留下评论和反馈。我想在此简要叙述一下此博客的搭建过程。 博客搭建过程1. 选择平台我选择了Hexo作为我的博客平台，因为它轻量且易于使用。 2. 安装Hexo：我按照官方文档安装了Hexo，并创建了一个新的博客项目。 下载node.js：Hexo依赖于Node.js，因此我需要先安装Node.js。我从官方网站下载了最新版本的Node.js，并按照安装说明进行安装。 安装Hexo：安装完成后，我使用npm安装Hexo命令行工具。1$ npm install -g hexo-cli 12$ node -v // 检查node.js版本$ npm -v // 检查npm版本 更换镜像源：为了加快安装速度，我更换了npm的镜像源为淘宝镜像。1$ npm config set registry https://registry.npmmirror.com 安装hexo: 安装完成后，我使用npm安装Hexo命令行工具。1$ npm install -g hexo-cli 1$ hexo -v // 检查hexo版本 创建博客项目：我使用Hexo命令行工具创建了一个新的博客项目。1$ hexo init my-blog // 创建博客项目 123456$ cd my-blog // 进入博客项目目录$ npm install // 安装依赖$ cd .. // 返回上一级目录$ dir // 查看目录结构$ hexo new &quot;我的第一篇博客&quot; // 创建新的博客文章$ hexo s // 启动本地服务器 3. 选择主题：我浏览了多个主题，最终选择了一个简洁而美观的主题。 选择主题：选择心仪的主题并克隆到本地themes目录1$ git clone https://github.com/hexojs/hexo-theme-landscape.git themes/landscape // 克隆主题到本地themes目录 配置主题：我修改了博客项目的配置文件，将主题设置为landscape。1$ vim _config.yml // 打开配置文件 1theme: landscape // 设置主题为landscape 重启服务器：修改配置文件后，我需要重启本地服务器才能生效。1$ hexo s // 重启本地服务器 4. 配置博客：我修改了配置文件，添加了必要的信息，如博客标题、作者、描述等。 修改配置文件：我修改了博客项目的配置文件，添加了必要的信息，如博客标题、作者、描述等。1$ vim _config.yml // 打开配置文件 123title: 我的博客 // 设置博客标题author: 我的姓名 // 设置作者姓名description: 分享技术、生活经验的个人博客 // 设置博客描述 5. 撰写内容：我开始撰写我的第一篇博客文章，并使用Markdown格式进行排版。 我详细描述了我在学习过程中的经验、遇到的问题以及解决方法。 创建文章文件：我在博客项目的source&#x2F;_posts目录下创建了一个新的Markdown文件，文件名就是我的第一篇博客的标题。1$ hexo new &quot;我的第一篇博客&quot; // 创建新的博客文章 编写文章内容：我在文章文件中编写了我的第一篇博客的内容。我使用Markdown格式进行排版，添加了标题、段落、列表、代码块、图片等元素。 这是Markdown语法链接：Markdown语法 6. 发布博客：我使用Hexo的生成和部署命令，将我的博客发布到GitHub Pages上。 申请GitHub Pages：我需要先在GitHub上创建一个新的仓库，用于存储我的博客项目。 登录GitHub账号，点击“New repository”按钮。 输入仓库名称，需注意的是，仓库名称必须与你的GitHub用户名相同且以“.github.io”结尾，才能将博客发布到GitHub Pages上。 点击“Create repository”按钮，创建新的仓库。 配置Hexo：我需要在博客项目的配置文件中添加一些信息，以告诉Hexo将博客发布到GitHub Pages上。1$ vim _config.yml // 打开配置文件 1234deploy: type: git repository: https://github.com/your-username/your-username.github.io.git // 替换为你的仓库URL branch: master // 替换为你的分支名称 清理缓存：在发布博客之前，我需要清理Hexo的缓存，以确保最新的配置生效。1$ hexo clean // 清理缓存 生成静态文件：我使用Hexo的生成命令，将博客项目中的Markdown文件转换为静态HTML文件。1$ hexo g // 生成静态文件 部署到GitHub Pages：我使用Hexo的部署命令，将生成的静态文件部署到GitHub Pages上。1$ hexo d // 部署到GitHub Pages 7. 持续更新：我计划定期更新博客，分享更多有趣的技术内容、生活经验以及个人思考。 结语我希望我的第一篇博客能够对读者们有所帮助，也希望能鼓励他们继续分享知识和经验。如果有任何问题或建议，欢迎在评论区留言。再次感谢你阅读我的博客！","categories":[{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"技术","slug":"技术","permalink":"https://forest-sweet.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-08-01T02:00:12.075Z","updated":"2025-08-01T02:00:12.075Z","comments":true,"path":"2025/08/01/hello-world/","permalink":"https://forest-sweet.github.io/2025/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://forest-sweet.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"技术","slug":"技术","permalink":"https://forest-sweet.github.io/tags/%E6%8A%80%E6%9C%AF/"}]}