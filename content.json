{"meta":{"title":"forest-sweet hexo blog","subtitle":"","description":"","author":"forest-sweet","url":"https://forest-sweet.github.io","root":"/"},"pages":[{"title":"归档","date":"2025-08-03T03:41:48.000Z","updated":"2025-08-03T13:47:47.385Z","comments":false,"path":"archives/index.html","permalink":"https://forest-sweet.github.io/archives/","excerpt":"","text":""},{"title":"分类","date":"2025-08-03T03:42:18.000Z","updated":"2025-08-03T03:45:41.707Z","comments":false,"path":"categories/index.html","permalink":"https://forest-sweet.github.io/categories/","excerpt":"","text":""},{"title":"关于","date":"2025-08-03T03:41:48.000Z","updated":"2025-08-03T03:45:07.331Z","comments":false,"path":"about/index.html","permalink":"https://forest-sweet.github.io/about/","excerpt":"","text":"这是我的博客"},{"title":"标签","date":"2025-08-03T03:42:48.000Z","updated":"2025-08-03T03:46:02.859Z","comments":false,"path":"tags/index.html","permalink":"https://forest-sweet.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"git","slug":"git","date":"2025-12-01T02:07:13.000Z","updated":"2025-12-01T09:32:20.165Z","comments":true,"path":"2025/12/01/git/","permalink":"https://forest-sweet.github.io/2025/12/01/git/","excerpt":"","text":"gitGit 是一个分布式版本控制系统，用于跟踪文件的更改，特别是源代码文件。它允许多个开发者协同工作，记录项目的历史版本，并且支持分支和合并等功能。 基本概念 仓库（Repository）：存储项目代码的地方，每个项目都有一个仓库。 分支（Branch）：项目的不同开发路径，每个分支都是独立的代码副本。 提交（Commit）：对项目代码的一次更改记录，每个提交都有一个唯一的标识符。 合并（Merge）：将一个分支的更改合并到另一个分支。 远程仓库（Remote Repository）：存储在远程服务器上的仓库，用于与多个开发者协同工作。 常用命令 git log：查看当前目录下提交历史记录。按q退出。","categories":[{"name":"git","slug":"git","permalink":"https://forest-sweet.github.io/categories/git/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://forest-sweet.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"https://forest-sweet.github.io/tags/git/"}]},{"title":"C++日常问题","slug":"C++日常问题","date":"2025-11-24T12:15:00.000Z","updated":"2026-01-31T12:47:21.221Z","comments":true,"path":"2025/11/24/C++日常问题/","permalink":"https://forest-sweet.github.io/2025/11/24/C++%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/","excerpt":"","text":"C++日常问题在日常使用C++编程时，可能会遇到一些常见的问题。以下是一些典型的问题及其解决方法。 类定义时，初始化列表顺序问题C++中成员初始化的顺序是按照类中成员声明的顺序，而不是初始化列表中的顺序。 12345678910111213141516171819202122232425262728class Building&#123; private: string idname; int idnumber; public: Building()&#123;&#125; Building(const string&amp; a,int b):idname(a),idnumber(b)&#123;&#125; void B_output()&#123; cout&lt;&lt;&quot;地址：&quot;&lt;&lt;idname&lt;&lt;endl; cout&lt;&lt;&quot;楼号：&quot;&lt;&lt;idnumber&lt;&lt;endl; &#125;&#125;;class Office : public Building&#123; private: string officename; int call; public: Office(const string&amp; a,int b,const string&amp; c=&quot;ttt&quot;,int d=897):officename(a),call(b),Building(c,d)&#123; cout&lt;&lt;&quot;构造完成\\n&quot;; &#125; void O_output()&#123; cout&lt;&lt;&quot;办公室名称：&quot;&lt;&lt;officename&lt;&lt;endl; cout&lt;&lt;&quot;电话：&quot;&lt;&lt;call&lt;&lt;endl; &#125;&#125;; &emsp;在上面的代码中，Office类的构造函数中，虽然初始化列表中先初始化了officename和call，但实际上Building类的成员会先被初始化，因为它们在类定义中先声明。所以若像上面代码中office中那样构造，则通过office对象调用B_output()方法时，会输出空字符串和0，而不是预期的地址和楼号。&emsp;因此，在初始化列表中，应该先初始化基类的成员，再初始化派生类的成员。不然会导致未定义的行为。如上面的代码中，应该将初始化列表改为： 123Office(const string&amp; a,int b,const string&amp; c=&quot;ttt&quot;,int d=897):Building(c,d),officename(a),call(b)&#123; cout&lt;&lt;&quot;构造完成\\n&quot;; &#125; 运算符重载&emsp;在C++中，可以通过运算符重载来定义自定义类型的运算符行为。例如，重载加法运算符+可以让两个自定义对象相加。&emsp;大致分为成员函数重载和友元函数重载两种方式。&emsp;成员函数重载是在类中定义一个成员函数，函数名就是要重载的运算符，函数参数就是要操作的对象。例如，重载加法运算符+可以在类中定义一个成员函数operator+，函数参数就是要相加的对象。&emsp;友元函数重载是在类外定义一个普通函数，函数名就是要重载的运算符，函数参数就是要操作的对象。例如，重载加法运算符+可以在类外定义一个普通函数operator+，函数参数就是要相加的对象。&emsp;需要注意的是，运算符重载只能对已有的运算符进行重载，不能创建新的运算符。例如，不能重载@运算符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class MyString&#123; private: string name1,name2; public: MyString(const string&amp;n1=&quot;&quot;,const string&amp;n2=&quot;&quot;):name1(n1),name2(n2)&#123; &#125; //friend MyString operator+(const MyString&amp; other1,const MyString&amp; other2); MyString add(const MyString&amp; other)const&#123; return MyString(name1+other.name1,name2+other.name2); &#125; MyString operator+(const MyString&amp; other)const&#123; return add(other); &#125; /**成员函数重载 MyString operator+(const MyString&amp; other)const&#123; MyString ans; ans.name1=name1+other.name1; ans.name2=name2+other.name2; return ans; &#125;**/ void output()&#123; cout&lt;&lt;name1&lt;&lt;endl; cout&lt;&lt;name2&lt;&lt;endl; &#125;&#125;;/**友元函数重载MyString operator+(const MyString&amp; other1,const MyString&amp; other2)const&#123; MyString ans; ans.name1=other1.name1+other2.name1; ans.name2=other1.name2+other2.name2; return ans;&#125;**/int main()&#123; MyString p1(&quot;li&quot;,&quot;bai&quot;),p2(&quot;wang&quot;,&quot;wei&quot;); MyString p3=p1+p2; p3.output();&#125; 成员函数重载（适合单 &#x2F; 双目运算符，隐含 this 指针），可以直接访问类的私有成员。this指针指向调用该函数的对象。如上面的代码中，p3&#x3D;p1+p2;中，p1调用operator+方法，等价于p1.operator+(p2)，this指针指向p1，other指向p2。所以左侧操作数必须是当前类对象。 友元函数重载（适合双目运算符，不隐含 this 指针），需要在类中声明为友元函数，才能访问类的私有成员。如上面的代码中，operator+方法中需要访问name1和name2，所以需要在类中声明为友元函数。&lt;&lt;,&gt;&gt;必须友元重载。 this指针&emsp;在C++中，this指针是一个隐含的指针，指向调用成员函数的对象。它可以用来访问对象的成员变量和成员函数。 用法 当成员函数的参数与成员变量同名时，使用this指针可以区分它们。 12345678class MyClass&#123; private: int value; public: void setValue(int value)&#123; this-&gt;value=value; // 使用this指针区分成员变量和参数，this-&gt;value指向成员变量，value指向参数 &#125;&#125;; 在成员函数中返回对象本身，可以使用this指针。 123456789class MyClass&#123; private: int value; public: MyClass&amp; setValue(int value)&#123; this-&gt;value=value; // 使用this指针返回对象本身 return *this; &#125;&#125;; 注意事项 this指针是一个常量指针，不能被修改。因此，不能使用this指针来调用其他成员函数。 this指针不占用类的大小 this指针实质是一个指向对象的指针，指向调用该函数的对象，所存放的地址是对象的首地址。 编译器会在成员函数中自动添加this指针，因此在成员函数中可以直接使用成员变量和成员函数，而不需要使用this指针。 12345678910void MyClass::setValue(MyClass* this,int value1)&#123; this-&gt;value=value1;&#125;// 等价于void MyClass::setValue(int value1)&#123; value=value1;&#125;s.setValue(10);// 等价于s.setValue(&amp;s,10); 静态成员函数没有this指针，因为静态成员函数不依赖于任何对象。它在对象未被实例化之前就存在，它是所以对象所共有的。因此，在类外调用静态成员函数时，不能通过对象来调用，只能通过类名来调用。 123456789class MyClass&#123; private: int value; public: static void setValue(int value)&#123; // 不能使用this指针，因为静态成员函数不依赖于任何对象，它可以直接访问类的静态成员变量和静态成员函数。 &#125;&#125;;MyClass::setValue(10); // 通过类名调用静态成员函数 案例12345678910111213141516171819202122232425262728class MyString&#123;private: string name1,name2;public: // 构造函数 MyString(const string&amp;n1=&quot;&quot;,const string&amp;n2=&quot;&quot;):name1(n1),name2(n2)&#123;&#125; // 成员函数 add MyString add(const MyString&amp; other)const&#123; return MyString(name1+other.name1, name2+other.name2); &#125; // 重载 + 运算符 MyString operator+(const MyString&amp; other)const&#123; return add(other); &#125; void output()&#123; cout&lt;&lt;name1&lt;&lt;endl; cout&lt;&lt;name2&lt;&lt;endl; &#125;&#125;;int main()&#123; MyString p1(&quot;li&quot;,&quot;bai&quot;),p2(&quot;wang&quot;,&quot;wei&quot;); MyString p3=p1+p2; // 核心调用：p1.operator+(p2) p3.output();&#125; add 成员函数中（隐含 this） 12345//实际编译器处理后等价于：MyString add(const MyString&amp; other)const&#123; // this 指向调用 add 函数的对象（比如 p1） return MyString(this-&gt;name1 + other.name1, this-&gt;name2 + other.name2);&#125; operator+ 成员函数中（隐含 this） 1234MyString operator+(const MyString&amp; other)const&#123; // this 指向调用 operator+ 函数的对象（比如 p1） return this-&gt;add(other); // 等价于 p1.add(p2)&#125; i++和++i的区别&emsp;在C++中，i++是后置递增运算符，表示先使用变量i的当前值，然后再将其值增加1，需要一个临时变量来存储当前值。而++i是前置递增运算符，表示先将变量i的值增加1，然后再使用它的新值。 &emsp;在循环迭代中，优先使用前置递增运算符++i，因为它的效率更高。性能层面：即使基础类型无差异，自定义类型（如 STL 迭代器 vector::iterator）中 ++i 性能更优，养成习惯可避免后续踩坑；规范层面：符合 C&#x2F;C++ 开发的通用编码规范，代码可读性和一致性更高。","categories":[{"name":"C++","slug":"C","permalink":"https://forest-sweet.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://forest-sweet.github.io/tags/C/"},{"name":"杂类","slug":"杂类","permalink":"https://forest-sweet.github.io/tags/%E6%9D%82%E7%B1%BB/"}]},{"title":"C++中cin、cin.get()、cin.getline()、getline()等函数的用法","slug":"cin与getline","date":"2025-10-23T14:25:13.000Z","updated":"2025-11-01T07:35:45.934Z","comments":true,"path":"2025/10/23/cin与getline/","permalink":"https://forest-sweet.github.io/2025/10/23/cin%E4%B8%8Egetline/","excerpt":"","text":"cin&gt;&gt;行为 基于”单词”的读取 以空白字符作为分隔（空格、制表符、换行符等） 跳过前导的空白字符 读取非空白字符，直到遇到下一个空白字符停止 不读取空白分隔符，将其留在输入缓冲区中 最基本，也是最常用的用法，输入一个数字：12345678910#include &lt;iostream&gt;using namespace std;main ()&#123;int a,b;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;a+b&lt;&lt;endl;&#125;//输入：2[回车]3[回车]//输出：5 ‘&gt;&gt;’ 是会过滤掉不可见字符（如 空格 回车，TAB 等） cin&gt;&gt;noskipws&gt;&gt;input[j];&#x2F;&#x2F;不想略过空白字符，那就使用 noskipws 流控制 接受一个字符串，遇“空格”、“TAB”、“回车”都结束123456789101112#include &lt;iostream&gt;using namespace std;main ()&#123;char a[20];cin&gt;&gt;a;cout&lt;&lt;a&lt;&lt;endl;&#125;//输入：jkljkljkl//输出：jkljkljkl//输入：jkljkl jkljkl //遇空格结束//输出：jkljkl cin.get()cin.get(字符变量名)可以用来接收字符12345678910#include &lt;iostream&gt;using namespace std;main ()&#123;char ch;ch=cin.get(); //或者cin.get(ch);cout&lt;&lt;ch&lt;&lt;endl;&#125;输入：jljkljkl输出：j cin.get(字符数组名,接收字符数目)用来接收一行字符串,可以接收空格123456789101112#include &lt;iostream&gt;using namespace std;main ()&#123;char a[20];cin.get(a,20);cout&lt;&lt;a&lt;&lt;endl;&#125;输入：jkl jkl jkl输出：jkl jkl jkl输入：abcdeabcdeabcdeabcdeabcde （输入25个字符）输出：abcdeabcdeabcdeabcd （接收19个字符+1个&#x27;\\0&#x27;） cin.getline()接受一个字符串，可以接收空格并输出12345678910111213141516#include &lt;iostream&gt;using namespace std;main ()&#123;char m[20];cin.getline(m,5);cout&lt;&lt;m&lt;&lt;endl;&#125;输入：jkljkljkl输出：jklj接受5个字符到m中，其中最后一个为&#x27;\\0&#x27;，所以只看到4个字符输出如果把5改成20：输入：jkljkljkl输出：jkljkljkl输入：jklf fjlsjf fjsdklf输出：jklf fjlsjf fjsdklf cin.getline()实际上有三个参数,当第三个参数省略时，系统默认为’\\0’如果将例子中cin.getline()改为cin.getline(m,5,’a’);当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk 当用在多维数组中的时候，也可以用cin.getline(m[i],20)之类的用法 getline()行为 基于”行”的读取 以换行符 \\n 作为分隔（可自定义其他分隔符） 读取所有字符，包括空格 遇到换行符时停止 读取并丢弃换行符，不留在缓冲区中 接受一个字符串，可以接收空格并输出123456789101112#include&lt;string&gt;using namespace std;main ()&#123;string str;getline(cin,str);cout&lt;&lt;str&lt;&lt;endl;&#125;输入：jkljkljkl输出：jkljkljkl输入：jkl jfksldfj jklsjfl输出：jkl jfksldfj jklsjfl cin.ignore()通常用于清除输入缓冲区中残留的无用字符（如换行符 \\n），避免对后续输入操作产生干扰。 清除换行符当使用 cin &gt;&gt; 读取数据后，输入缓冲区可能残留换行符 \\n，若后续使用 getline(cin, str) 读取整行，会直接读取到空行（因为 getline 遇到 \\n 会停止）。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int num; cout &lt;&lt; &quot;输入一个数字：&quot;; cin &gt;&gt; num; // 输入数字后按回车，缓冲区残留 &#x27;\\n&#x27; // 忽略缓冲区中残留的 &#x27;\\n&#x27;（默认忽略1个字符） cin.ignore(); string str; cout &lt;&lt; &quot;输入一行字符串：&quot;; getline(cin, str); // 此时可正常读取整行 cout &lt;&lt; &quot;数字：&quot; &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;字符串：&quot; &lt;&lt; str &lt;&lt; endl; return 0;&#125; 忽略指定数量的字符1cin.ignore(3); // 忽略接下来的3个字符 混合使用 cin &gt;&gt; 和 getline 的陷阱int num; string str; cout &lt;&lt; &quot;Enter a number: &quot;; cin &gt;&gt; num; // 用户输入数字后按回车 cout &lt;&lt; &quot;Enter a string: &quot;; getline(cin, str); // 这行代码会直接跳过！ cout &lt;&lt; &quot;Number: &quot; &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;String: &quot; &lt;&lt; str &lt;&lt; &quot;(为什么是空的？)&quot; &lt;&lt; endl; 原因： cin &gt;&gt; num 只读取了数字，而用户按下的回车键（‘\\n’） 留在了输入缓冲区中。紧接着的 getline(cin, str) 一遇到这个换行符就认为读取结束，所以看起来它被“跳过”了。解决方案： 在 cin &gt;&gt; 之后，使用 cin.ignore() 来清空缓冲区中的换行符。","categories":[{"name":"C++","slug":"C","permalink":"https://forest-sweet.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://forest-sweet.github.io/tags/C/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2025-10-02T04:26:21.000Z","updated":"2025-10-10T13:35:51.469Z","comments":true,"path":"2025/10/02/KMP算法/","permalink":"https://forest-sweet.github.io/2025/10/02/KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"KMP算法我是在完成力扣28题时，才知道KMP算法的。此算法可以在O(n+m)的时间复杂度内，完成字符串匹配，相较于暴力匹配的O(nm)时间复杂度，KMP算法的效率要高很多。因此在这学习并记录一下KMP算法的实现。 KMP算法原理KMP算法的核心思想是利用已经匹配过的信息，避免重复匹配。当在主字符串中遇到不匹配的字符时，KMP算法不会回溯主字符串，而是利用模式字符串中的部分匹配信息，直接跳过一些字符，从而提高匹配效率。与暴力匹配不同，KMP算法在匹配过程中，不会重复匹配已经匹配过的字符。 1. 暴力匹配暴力匹配是一种简单的字符串匹配算法，其基本思想是从主字符串的第一个字符开始，与模式字符串的第一个字符进行比较。如果匹配成功，继续比较下一个字符；如果匹配失败，将主字符串的下一个字符作为新的起始位置，重新与模式字符串的第一个字符进行比较。重复这个过程，直到找到匹配的子字符串或主字符串遍历完毕。 下面通过图示来说明暴力匹配的过程： 这个算法的原理很简单，实现起来也十分容易，但最大的问题在于它的时间复杂度，假如你运气不好，恰好碰到主串和子串都是若干个 A，最后仅跟一个 B 的情况。这个时候算法会很傻地把前面的 A 都比对完，然后发现最后一个字符不匹配，于是跳回下一个字符重新比对，做了不少的无用功。 2. KMP算法KMP算法通过预处理模式字符串，构建前缀表（也称为next数组），来记录模式字符串中每个位置的最长相同前后缀的长度。当在主字符串中遇到不匹配的字符时，KMP算法利用前缀表，直接跳过一些字符，不像是暴力匹配那样，重新从主串下一个字符开始。换句话说，我们不希望递减主串的这个指针，而让它永远向前方移动，从而避免重复匹配，提高匹配效率。 KMP算法步骤1.构建部分匹配表（next数组）：前缀： 模式字符串的前缀是指从字符串的开头开始的连续子串，但不包括最后一个字符。后缀： 模式字符串的后缀是指从字符串的结尾开始的连续子串，但不包括第一个字符。部分匹配值： 前缀和后缀的最长公共元素的长度。例如，模式字符串”ABABC”的前缀有”A”, “AB”, “ABA”, “ABAB”，后缀有”C”, “BC”, “ABC”, “BABC”，最长公共元素的长度为2，因此”ABABC”的部分匹配值为2。 next 数组的本质，其实就是寻找子串中相同前后缀的长度，并且一定是最长的前后缀。例如，模式字符串”ABABC”的next数组为[-1, 0, 0, 1, 2]，其中next[i]表示模式字符串的前i个字符中，最长的相同前后缀的长度。 next 数组的构建过程：定义两个指针i和j，j代表前缀的结束位置和子串的最长相等前后缀的长度，i代表后缀的结束位置。 j初始值为0，i初始值为1,next[0]初始值为0。 当模式字符串的第i个字符和第j个字符相等时，说明找到了一个更长的相同前后缀，j++;next[i] &#x3D; j;i++; 当模式字符串的第i个字符和第j个字符不相等时，说明当前的相同前后缀长度不能扩展，需要回退到前一个位置的相同前后缀长度。这可以通过将j回退到next[j-1]的位置来实现。(可能需要回退多次，直到j为0或当前字符匹配)，若j回退到0仍不匹配，说明当前字符与前缀的第一个字符也不匹配，next[i] &#x3D; 0;i++; 初始时 j为0且当前字符不匹配时，next[i] &#x3D; 0;i++; 当前字符匹配时，j++;next[i] &#x3D; j;i++; 字符不匹配时，j回退到next[j-1]的位置，直到j为0或当前字符匹配。 构建next数组的伪代码：j,i,next[0]有两种初始化情况: j&#x3D;0,i&#x3D;1,next[0]&#x3D;0,更易理解； j&#x3D;-1,i&#x3D;0,next[0]&#x3D;-1,更方便计算next数组； 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;// 构建next数组 (next[0] = 0)vector&lt;int&gt; buildNext(const string&amp; pattern) &#123; int n = pattern.length(); vector&lt;int&gt; next(n, 0); // 初始化为0 int j = 0, i = 1; // j初始化为0，i初始化为1 while (i &lt; n) &#123; if (pattern[i] == pattern[j]) &#123; j++; // 找到匹配，j增加 next[i] = j; // 设置next值 i++; // i向后移动 &#125; else &#123; if (j &gt; 0) &#123; j = next[j - 1]; // 回退j到前一个位置的next值 &#125; else &#123; next[i] = 0; // j为0时，无法回退，设置next为0 i++; // i向后移动 &#125; &#125; &#125; return next;&#125; 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;// 构建next数组 (next[0] = -1)vector&lt;int&gt; buildNext(const string&amp; pattern) &#123; int n = pattern.length(); vector&lt;int&gt; next(n, -1); int i = 0, j = -1; while (i &lt; n - 1) &#123; if (j == -1 || pattern[i] == pattern[j]) &#123; i++; j++; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125; return next;&#125; 2. 进行字符串匹配： - 初始化两个指针i和j，分别指向主字符串和模式字符串的第一个字符。 - 当j为-1时，或者当前字符匹配时，i和j都向右移动一位。 - 当当前字符不匹配时，j回退到next[j]的位置，直到j为-1或当前字符匹配。 - 如果j移动到了模式字符串的末尾，说明匹配成功，返回匹配的起始位置。 - 否则，继续匹配。 12345678910111213141516171819202122232425//KMP搜索算法vector&lt;int&gt; kmpSearch(const string&amp; text, const string&amp; pattern, const vector&lt;int&gt;&amp; next) &#123; vector&lt;int&gt; matches; int n = text.length(); int m = pattern.length(); int i = 0, j = 0; while (i &lt; n) &#123; if (j == -1 || text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; // 找到完整匹配 if (j == m) &#123; matches.push_back(i - j); // 找到匹配后，模式串可能还有重叠部分可以继续匹配,继续寻找下一个匹配 //因为当前匹配的末尾部分可能包含下一个匹配的开头部分，所以需要回退到前一个位置的next值 j = next[j - 1]; // 回退到前一个位置 &#125; &#125; return matches;&#125; KMP算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int strStr(string haystack, string needle) &#123; //边界情况处理：如果needle为空字符串，返回0 int n = haystack.size(), m = needle.size(); if (m == 0) &#123; return 0; &#125; //构建部分匹配表（next数组） vector&lt;int&gt; pi(m); for (int i = 1, j = 0; i &lt; m; i++) &#123; while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (needle[i] == needle[j]) &#123; j++; &#125; pi[i] = j; &#125; //进行字符串匹配(只返回第一个匹配位置) for (int i = 0, j = 0; i &lt; n; i++) &#123; while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (haystack[i] == needle[j]) &#123; j++; &#125; if (j == m) &#123; return i - m + 1; &#125; &#125; //进行字符串匹配(返回所有匹配位置) vector&lt;int&gt; result; for (int i = 0, j = 0; i &lt; n; i++) &#123; while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (haystack[i] == needle[j]) &#123; j++; &#125; if (j == m) &#123; result.push_back(i - m + 1); // 记录位置 // 关键：继续匹配，回退j以便找到重叠的匹配 j = pi[j - 1]; &#125; &#125; return -1;//或return result; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class KMP &#123;private: string pattern; vector&lt;int&gt; next; public: // 构造函数，预计算next数组 KMP(const string&amp; pat) : pattern(pat) &#123; buildNext(); &#125; // 构建next数组 void buildNext() &#123; int n = pattern.length(); next.resize(n, -1); int i = 0, j = -1; while (i &lt; n - 1) &#123; if (j == -1 || pattern[i] == pattern[j]) &#123; i++; j++; // 优化：如果回退后字符相同，则继续回退 //核心思想：避免已知必然失败的比较，直接跳转到更有可能成功的位置,这种优化在处理包含大量重复字符的模式串时效果尤其明显！ if (pattern[i] != pattern[j]) &#123; next[i] = j; &#125; else &#123; next[i] = next[j]; &#125; &#125; else &#123; j = next[j]; &#125; &#125; &#125; // 搜索所有匹配位置 vector&lt;int&gt; search(const string&amp; text) &#123; vector&lt;int&gt; matches; int n = text.length(); int m = pattern.length(); int i = 0, j = 0; while (i &lt; n) &#123; if (j == -1 || text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; if (j == m) &#123; matches.push_back(i - j); j = next[j - 1]; &#125; &#125; return matches; &#125; // 搜索第一个匹配位置 int searchFirst(const string&amp; text) &#123; int n = text.length(); int m = pattern.length(); int i = 0, j = 0; while (i &lt; n) &#123; if (j == -1 || text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; if (j == m) &#123; return i - j; &#125; &#125; return -1; // 未找到 &#125; // 打印next数组 void printNext() const &#123; cout &lt;&lt; &quot;Pattern: &quot; &lt;&lt; pattern &lt;&lt; endl; cout &lt;&lt; &quot;Next array: [&quot;; for (int i = 0; i &lt; next.size(); i++) &#123; cout &lt;&lt; next[i]; if (i &lt; next.size() - 1) cout &lt;&lt; &quot;, &quot;; &#125; cout &lt;&lt; &quot;]&quot; &lt;&lt; endl; &#125;&#125;;// 测试函数void testKMP() &#123; string text = &quot;ABABDABACDABABCABAB&quot;; string pattern = &quot;ABABC&quot;; // 创建KMP对象 KMP kmp(pattern); // 打印信息 cout &lt;&lt; &quot;Text: &quot; &lt;&lt; text &lt;&lt; endl; kmp.printNext(); // 搜索所有匹配 vector&lt;int&gt; matches = kmp.search(text); cout &lt;&lt; &quot;所有匹配位置: &quot;; for (int pos : matches) &#123; cout &lt;&lt; pos &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; // 搜索第一个匹配 int firstMatch = kmp.searchFirst(text); cout &lt;&lt; &quot;第一个匹配位置: &quot; &lt;&lt; firstMatch &lt;&lt; endl;&#125;int main() &#123; testKMP(); return 0;&#125; 总结KMP算法是一种高效的字符串匹配算法，通过利用已经匹配过的信息，避免重复匹配，从而提高匹配效率。在实际应用中，KMP算法被广泛用于字符串匹配、文本编辑器、编译器等领域。","categories":[{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://forest-sweet.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2025-08-01T02:07:13.000Z","updated":"2025-10-02T14:08:32.223Z","comments":true,"path":"2025/08/01/我的第一篇博客/","permalink":"https://forest-sweet.github.io/2025/08/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"我的第一篇博客欢迎来到我的博客！这是我发布的第一篇文章。在这里，我将分享我的学习经历、技术见解以及生活点滴。希望你能在这里找到有价值的内容，也欢迎你留下评论和反馈。我想在此简要叙述一下此博客的搭建过程。 博客搭建过程1. 选择平台我选择了Hexo作为我的博客平台，因为它轻量且易于使用。 2. 安装Hexo：我按照官方文档安装了Hexo，并创建了一个新的博客项目。 下载node.js：Hexo依赖于Node.js，因此我需要先安装Node.js。我从官方网站下载了最新版本的Node.js，并按照安装说明进行安装。 安装Hexo：安装完成后，我使用npm安装Hexo命令行工具。1$ npm install -g hexo-cli 12$ node -v // 检查node.js版本$ npm -v // 检查npm版本 更换镜像源：为了加快安装速度，我更换了npm的镜像源为淘宝镜像。1$ npm config set registry https://registry.npmmirror.com 安装hexo: 安装完成后，我使用npm安装Hexo命令行工具。1$ npm install -g hexo-cli 1$ hexo -v // 检查hexo版本 创建博客项目：我使用Hexo命令行工具创建了一个新的博客项目。1$ hexo init my-blog // 创建博客项目 123456$ cd my-blog // 进入博客项目目录$ npm install // 安装依赖$ cd .. // 返回上一级目录$ dir // 查看目录结构$ hexo new &quot;我的第一篇博客&quot; // 创建新的博客文章$ hexo s // 启动本地服务器 3. 选择主题：我浏览了多个主题，最终选择了一个简洁而美观的主题。 选择主题：选择心仪的主题并克隆到本地themes目录1$ git clone https://github.com/hexojs/hexo-theme-landscape.git themes/landscape // 克隆主题到本地themes目录 配置主题：我修改了博客项目的配置文件，将主题设置为landscape。1$ vim _config.yml // 打开配置文件 1theme: landscape // 设置主题为landscape 重启服务器：修改配置文件后，我需要重启本地服务器才能生效。1$ hexo s // 重启本地服务器 4. 配置博客：我修改了配置文件，添加了必要的信息，如博客标题、作者、描述等。 修改配置文件：我修改了博客项目的配置文件，添加了必要的信息，如博客标题、作者、描述等。1$ vim _config.yml // 打开配置文件 123title: 我的博客 // 设置博客标题author: 我的姓名 // 设置作者姓名description: 分享技术、生活经验的个人博客 // 设置博客描述 5. 撰写内容：我开始撰写我的第一篇博客文章，并使用Markdown格式进行排版。 我详细描述了我在学习过程中的经验、遇到的问题以及解决方法。 创建文章文件：我在博客项目的source&#x2F;_posts目录下创建了一个新的Markdown文件，文件名就是我的第一篇博客的标题。1$ hexo new &quot;我的第一篇博客&quot; // 创建新的博客文章 编写文章内容：我在文章文件中编写了我的第一篇博客的内容。我使用Markdown格式进行排版，添加了标题、段落、列表、代码块、图片等元素。 这是Markdown语法链接：Markdown语法 6. 发布博客：我使用Hexo的生成和部署命令，将我的博客发布到GitHub Pages上。 申请GitHub Pages：我需要先在GitHub上创建一个新的仓库，用于存储我的博客项目。 登录GitHub账号，点击“New repository”按钮。 输入仓库名称，需注意的是，仓库名称必须与你的GitHub用户名相同且以“.github.io”结尾，才能将博客发布到GitHub Pages上。 点击“Create repository”按钮，创建新的仓库。 配置Hexo：我需要在博客项目的配置文件中添加一些信息，以告诉Hexo将博客发布到GitHub Pages上。1$ vim _config.yml // 打开配置文件 1234deploy: type: git repository: https://github.com/your-username/your-username.github.io.git // 替换为你的仓库URL branch: master // 替换为你的分支名称 清理缓存：在发布博客之前，我需要清理Hexo的缓存，以确保最新的配置生效。1$ hexo clean // 清理缓存 生成静态文件：我使用Hexo的生成命令，将博客项目中的Markdown文件转换为静态HTML文件。1$ hexo g // 生成静态文件 部署到GitHub Pages：我使用Hexo的部署命令，将生成的静态文件部署到GitHub Pages上。1$ hexo d // 部署到GitHub Pages 7. 持续更新：我计划定期更新博客，分享更多有趣的技术内容、生活经验以及个人思考。 结语我希望我的第一篇博客能够对读者们有所帮助，也希望能鼓励他们继续分享知识和经验。如果有任何问题或建议，欢迎在评论区留言。再次感谢你阅读我的博客！","categories":[{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"技术","slug":"技术","permalink":"https://forest-sweet.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-08-01T02:00:12.075Z","updated":"2025-08-01T02:00:12.075Z","comments":true,"path":"2025/08/01/hello-world/","permalink":"https://forest-sweet.github.io/2025/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"git","slug":"git","permalink":"https://forest-sweet.github.io/categories/git/"},{"name":"C++","slug":"C","permalink":"https://forest-sweet.github.io/categories/C/"},{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://forest-sweet.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"https://forest-sweet.github.io/tags/git/"},{"name":"C++","slug":"C","permalink":"https://forest-sweet.github.io/tags/C/"},{"name":"杂类","slug":"杂类","permalink":"https://forest-sweet.github.io/tags/%E6%9D%82%E7%B1%BB/"},{"name":"算法","slug":"算法","permalink":"https://forest-sweet.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://forest-sweet.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"博客","slug":"博客","permalink":"https://forest-sweet.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}